import numpy as np
from numba import njit
from scipy import signal as sp
from scipy import interpolate


@njit(cache=False)
def make_sinc_filter(beta, tap_cnt, sps, offset=0):
    """
        return the taps of a sinc filter
    """
    ntap_cnt = tap_cnt + ((tap_cnt + 1) % 2)
    t_index = np.arange(-(ntap_cnt - 1) // 2, (ntap_cnt - 1) // 2 + 1) / np.double(sps)

    taps = np.sinc(beta * t_index + offset)
    taps /= np.sum(taps)

    return taps[:tap_cnt]


def awgn(tensor: np.ndarray, noise_power_db: float) -> np.ndarray:
    """Adds zero-mean complex additive white Gaussian noise with power of 
    noise_power_db.

    Args:
        tensor: (:class:`numpy.ndarray`):
            (batch_size, vector_length, ...)-sized tensor.

        noise_power_db (:obj:`float`):
            Defined as 10*log10(E[|n|^2]).

    Returns:
        transformed (:class:`numpy.ndarray`):
            Tensor with added noise.
    """
    real_noise = np.random.randn(*tensor.shape)
    imag_noise = np.random.randn(*tensor.shape)
    return tensor + (10.0**(noise_power_db/20.0))*(real_noise + 1j*imag_noise)/np.sqrt(2)


def time_varying_awgn(
    tensor: np.ndarray, 
    noise_power_db_low: float, 
    noise_power_db_high: float, 
    inflections: int, 
    random_regions: bool,
) -> np.ndarray:
    """Adds time-varying complex additive white Gaussian noise with power
    levels in range (`noise_power_db_low`, `noise_power_db_high`) and with
    `inflections` number of inflection points spread over the input tensor
    randomly if `random_regions` is True or evely spread if False

    Args:
        tensor: (:class:`numpy.ndarray`):
            (batch_size, vector_length, ...)-sized tensor.

        noise_power_db_low (:obj:`float`):
            Defined as 10*log10(E[|n|^2]).
            
        noise_power_db_high (:obj:`float`):
            Defined as 10*log10(E[|n|^2]).
            
        inflections (:obj:`int`):
            Number of inflection points for time-varying nature
            
        random_regions (:obj:`bool`):
            Specify if inflection points are randomly spread throughout tensor
            or if evenly spread

    Returns:
        transformed (:class:`numpy.ndarray`):
            Tensor with added noise.
    """
    real_noise = np.random.randn(*tensor.shape)
    imag_noise = np.random.randn(*tensor.shape)
    noise_power_db = np.empty(*tensor.shape)
    
    if inflections == 0:
        inflection_indices = np.array([0, tensor.shape[0]])
    else:
        if random_regions:
            inflection_indices = np.sort(np.random.choice(tensor.shape[0], size=inflections, replace=False))
            inflection_indices = np.append(inflection_indices, tensor.shape[0])
            inflection_indices = np.insert(inflection_indices, 0, 0)
        else:
            inflection_indices = np.arange(inflections+2) * int(tensor.shape[0] / (inflections+1))

    for idx in range(len(inflection_indices)-1):
        start_idx = inflection_indices[idx]
        stop_idx = inflection_indices[idx+1]
        duration = stop_idx - start_idx
        start_power = noise_power_db_low if idx%2 == 0 else noise_power_db_high
        stop_power = noise_power_db_high if idx%2 == 0 else noise_power_db_low
        noise_power_db[start_idx:stop_idx] = np.linspace(start_power, stop_power, duration)
        
    return tensor + (10.0**(noise_power_db/20.0))*(real_noise + 1j*imag_noise)/np.sqrt(2)


def rayleigh_fading(
    tensor: np.ndarray, 
    coherence_bandwidth: float, 
    power_delay_profile: np.ndarray,
) -> np.ndarray:
    """Applies Rayleigh fading channel to tensor. Taps are generated by 
    interpolating and filtering Gaussian taps.

    Args:
        tensor: (:class:`numpy.ndarray`):
            (batch_size, vector_length, ...)-sized tensor.

        coherence_bandwidth (:obj:`float`):
            coherence_bandwidth relative to the sample rate in [0, 1.0]

        power_delay_profile (:obj:`float`):
            power_delay_profile assigned to channel

    Returns:
        transformed (:class:`numpy.ndarray`):
            Tensor that has undergone Rayleigh Fading.

    """
    num_taps = int(np.ceil(1.0 / coherence_bandwidth))  # filter length to get desired coherence bandwidth
    power_taps = np.sqrt(np.interp(
        np.linspace(0, 1.0, 100*num_taps),
        np.linspace(0, 1.0, len(power_delay_profile)),
        power_delay_profile
    ))
    # Generate initial taps
    rayleigh_taps = (np.random.randn(num_taps) + 1j * np.random.randn(num_taps))  # multi-path channel

    # Linear interpolate taps by a factor of 100 -- so we can get accurate coherence bandwidths
    old_time = np.linspace(0, 1.0, num_taps, endpoint=True)
    real_tap_function = interpolate.interp1d(old_time, rayleigh_taps.real)
    imag_tap_function = interpolate.interp1d(old_time, rayleigh_taps.imag)

    new_time = np.linspace(0, 1.0, 100*num_taps, endpoint=True)
    rayleigh_taps = real_tap_function(new_time) + 1j*imag_tap_function(new_time)
    rayleigh_taps *= power_taps

    # Ensure that we maintain the same amount of power before and after the transform
    input_power = np.linalg.norm(tensor)
    tensor = sp.upfirdn(rayleigh_taps, tensor, up=100, down=100)[-tensor.shape[0]:]
    output_power = np.linalg.norm(tensor)
    tensor = np.multiply(input_power/output_power, tensor)
    return tensor


def phase_offset(tensor: np.ndarray, phase: float) -> np.ndarray:
    """ Applies a phase rotation to tensor

    Args:
        tensor: (:class:`numpy.ndarray`):
            (batch_size, vector_length, ...)-sized tensor.

        phase (:obj:`float`):
            phase to rotate sample in [-pi, pi]

    Returns:
        transformed (:class:`numpy.ndarray`):
            Tensor that has undergone a phase rotation

    """
    return tensor*np.exp(1j*phase)


@njit(cache=False)
def impulsive_interference(tensor: np.ndarray, amp: float, per_offset: float):
    """ Applies an impulsive interferer to tensor

    Args:
        tensor: (:class:`numpy.ndarray`):
            (batch_size, vector_length, ...)-sized tensor.

        amp (:obj:`float`):
            Maximum vector magnitude of complex interferer signal
        
        per_offset (:obj:`float`)
            Interferer offset into the tensor as expressed in a fraction of the tensor length.

    """
    beta = .3
    num_samps = len(tensor)
    sinc_pulse = make_sinc_filter(beta, num_samps, .1, 0)
    imp = amp*np.roll(sinc_pulse / np.max(sinc_pulse), int(per_offset * num_samps))
    rand_phase = np.random.uniform(0, 2 * np.pi)
    imp = np.exp(1j * rand_phase) * imp
    return tensor + imp
